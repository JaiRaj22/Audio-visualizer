import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# Create a simple test image with patterns
size = 256
x = np.linspace(-5, 5, size)
y = np.linspace(-5, 5, size)
X, Y = np.meshgrid(x, y)

# Create figure
fig, axes = plt.subplots(2, 2, figsize=(12, 12))
fig.suptitle('2D Fourier Transform Animation', fontsize=16, fontweight='bold')

# Will store the image
image = np.zeros_like(X)

# Setup subplots
im1 = axes[0, 0].imshow(image, cmap='gray', vmin=0, vmax=1)
axes[0, 0].set_title('Original Image', fontsize=12)
axes[0, 0].axis('off')

im2 = axes[0, 1].imshow(image, cmap='gray')
axes[0, 1].set_title('2D FFT (Magnitude)', fontsize=12)
axes[0, 1].axis('off')

im3 = axes[1, 0].imshow(image, cmap='gray')
axes[1, 0].set_title('Low Frequency Components', fontsize=12)
axes[1, 0].axis('off')

im4 = axes[1, 1].imshow(image, cmap='gray')
axes[1, 1].set_title('High Frequency Components', fontsize=12)
axes[1, 1].axis('off')

# Text showing current pattern
text = fig.text(0.5, 0.02, '', ha='center', fontsize=11,
                bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))

def create_pattern(frame):
    """Create different patterns over time"""
    # Normalize frame to 0-1
    t = (frame % 120) / 120
    
    if frame < 30:
        # Vertical stripes
        pattern = np.sin(2 * np.pi * 5 * X * (t + 0.5))
        description = "Adding Vertical Stripes"
    elif frame < 60:
        # Horizontal stripes
        t_local = (frame - 30) / 30
        pattern = (np.sin(2 * np.pi * 5 * X * 1.5) + 
                  t_local * np.sin(2 * np.pi * 5 * Y * 1.5))
        description = "Adding Horizontal Stripes"
    elif frame < 90:
        # Circular pattern
        t_local = (frame - 60) / 30
        R = np.sqrt(X**2 + Y**2)
        pattern = (np.sin(2 * np.pi * 5 * X * 1.5) + 
                  np.sin(2 * np.pi * 5 * Y * 1.5) +
                  t_local * np.sin(2 * np.pi * 2 * R))
        description = "Adding Circular Pattern"
    else:
        # Complex pattern
        t_local = (frame - 90) / 30
        R = np.sqrt(X**2 + Y**2)
        theta = np.arctan2(Y, X)
        pattern = (np.sin(2 * np.pi * 5 * X * 1.5) + 
                  np.sin(2 * np.pi * 5 * Y * 1.5) +
                  np.sin(2 * np.pi * 2 * R) +
                  t_local * 0.5 * np.sin(5 * theta))
        description = "Adding Angular Pattern"
    
    return pattern, description

def animate(frame):
    # Create pattern
    pattern, description = create_pattern(frame)
    
    # Normalize to 0-1
    image = (pattern - pattern.min()) / (pattern.max() - pattern.min())
    
    # Update original image
    im1.set_data(image)
    
    # Compute 2D FFT
    fft2d = np.fft.fft2(image)
    fft2d_shifted = np.fft.fftshift(fft2d)
    magnitude_spectrum = np.log(np.abs(fft2d_shifted) + 1)
    
    # Update FFT magnitude
    im2.set_data(magnitude_spectrum)
    im2.set_clim(vmin=0, vmax=magnitude_spectrum.max())
    
    # Low frequency filter (keep center)
    mask_low = np.zeros_like(fft2d_shifted)
    center = size // 2
    radius = 20
    y_coords, x_coords = np.ogrid[:size, :size]
    mask_region = (x_coords - center)**2 + (y_coords - center)**2 <= radius**2
    mask_low[mask_region] = 1
    
    # Apply low frequency filter
    fft_low = fft2d_shifted * mask_low
    image_low = np.fft.ifft2(np.fft.ifftshift(fft_low))
    image_low = np.real(image_low)
    im3.set_data(image_low)
    im3.set_clim(vmin=image_low.min(), vmax=image_low.max())
    
    # High frequency filter (remove center)
    mask_high = 1 - mask_low
    fft_high = fft2d_shifted * mask_high
    image_high = np.fft.ifft2(np.fft.ifftshift(fft_high))
    image_high = np.real(image_high)
    im4.set_data(image_high)
    im4.set_clim(vmin=image_high.min(), vmax=image_high.max())
    
    # Update text
    text.set_text(description)
    
    return im1, im2, im3, im4, text

# Create animation
anim = FuncAnimation(fig, animate, frames=120, interval=50, blit=True, repeat=True)

plt.tight_layout()
plt.show()